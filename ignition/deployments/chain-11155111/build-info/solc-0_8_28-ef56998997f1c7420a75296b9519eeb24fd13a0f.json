{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-ef56998997f1c7420a75296b9519eeb24fd13a0f",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/Fund.sol": "project/contracts/Fund.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@chainlink/contracts/=npm/@chainlink/contracts@1.4.0/"
      ]
    },
    "sources": {
      "npm/@chainlink/contracts@1.4.0/src/v0.8/shared/interfaces/AggregatorV3Interface.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
      },
      "project/contracts/Fund.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol\";\n\ncontract Fund {\n    mapping(address => uint) public funds; // user address => amount funded\n\n    uint public constant MINIMUM = 1 * 10 ** 18; // 1 usd\n    uint public constant TARGET = 2 * 10 ** 18; // 2 usd\n\n    uint public deployTime; // timestamp of contract deployment\n    uint public locktime; // time after which funds can be withdrawn\n\n    address public owner;\n\n    AggregatorV3Interface internal priceFeed;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not the owner\");\n        _;\n    }\n\n    constructor(uint locktime_) {\n        locktime = locktime_;\n        deployTime = block.timestamp;\n\n        owner = msg.sender;\n        funds[owner] = 0;\n\n        // sepolia ETH/USD price feed\n        priceFeed = AggregatorV3Interface(\n            0x694AA1769357215DE4FAC081bf1f309aDC325306\n        );\n    }\n\n    //  returns the lock time\n    function getLockTime() public view returns (uint) {\n        return locktime;\n    }\n\n    // returns the amount funded by a specific address\n    function getFunds(address funder_) external view returns (uint) {\n        return funds[funder_];\n    }\n\n    // returns true if the funding period is over\n    function isPeriodOver() external view returns (bool) {\n        return block.timestamp >= deployTime + locktime;\n    }\n\n    // returns true if the funding target is reached\n    function isTargetReached() external view returns (bool) {\n        return address(this).balance >= TARGET;\n    }\n\n    // for testing purposes only: allows setting the deploy time\n    function setDeployTime() external {\n        deployTime = block.timestamp;\n    }\n\n    // allows users to fund the contract\n    function fund() external payable returns (bool) {\n        require(block.timestamp < deployTime + locktime, \"Funding period over\");\n        uint _amountInUsd = (uint(getPrice()) * msg.value) /\n            (10 ** priceFeed.decimals());\n        require(_amountInUsd >= MINIMUM, \"Minimum funding not met\");\n        funds[msg.sender] += msg.value;\n        return true;\n    }\n\n    // allows the owner to withdraw funds if the target is reached\n    function withdraw() external onlyOwner returns (bool) {\n        require(block.timestamp >= deployTime + locktime, \"Funds are locked\");\n        require(address(this).balance >= TARGET, \"Target not reached\");\n\n        (bool _success, ) = payable(owner).call{value: address(this).balance}(\n            \"\"\n        );\n        require(_success, \"Failed to withdraw Ether\");\n        // reset the funds mapping\n        funds[owner] = 0;\n\n        return true;\n    }\n\n    // allows users to refund their funds if the target is not reached\n    function refund() external returns (bool) {\n        require(block.timestamp >= deployTime + locktime, \"Funds are locked\");\n        require(address(this).balance < TARGET, \"Target was reached\");\n\n        uint _amount = funds[msg.sender];\n        require(_amount > 0, \"No funds to refund\");\n        // reset the user's funded amount\n        funds[msg.sender] = 0;\n\n        (bool _success, ) = payable(msg.sender).call{value: _amount}(\"\");\n        require(_success, \"Failed to refund Ether\");\n\n        return true;\n    }\n\n    // returns the latest price\n    function getPrice() public view returns (int) {\n        (, int _price, , , ) = priceFeed.latestRoundData();\n        return _price; // price is in 8 decimal places\n    }\n\n    // returns the conversion rate from wei to usd\n    function getConversionRate(uint weiAmount_) external view returns (uint) {\n        int _price = getPrice();\n        uint _ethAmountInUsd = (uint(_price) * weiAmount_) /\n            (10 ** priceFeed.decimals());\n        return _ethAmountInUsd;\n    }\n\n    // returns the number of decimals of the price feed\n    function getPriceFeedDecimals() external view returns (uint8) {\n        return priceFeed.decimals();\n    }\n\n    // transfer ownership to a new address\n    function transferOwnership(address newOwner_) external onlyOwner {\n        require(newOwner_ != address(0), \"Invalid address\");\n        owner = newOwner_;\n    }\n}\n"
      }
    }
  }
}